package main

import (
	"fmt"
	"image"
	_ "image/gif"
	_ "image/jpeg"
	"image/png"
	"io"
	"log"
	"net/http"
	"net/url"
	"regexp"
	"runtime"
	"strings"

	"github.com/google/uuid"
)

const (
	TRIES         = 30
	MUTATIONS     = 10000
	PIXELSAMPLING = 8
	MAXSIZE       = 300
)

var urlArg = regexp.MustCompile("url=(.*)")

var sessionManager = NewSessionManager()

//
// Server code
//

func getSessionID(r *http.Request) (uuid.UUID, error) {
	cookies := r.Cookies()

	for i := 0; i < len(cookies); i++ {
		if cookies[i].Name == "Session-ID" {
			return uuid.Parse(cookies[i].Value)
		}
	}

	return uuid.UUID{}, &NoSessionFound{}
}

// Returns the url query parameter
// e.g. in /remote/img?url=wwww.google.com, returns www.google.com
func urlParam(r *http.Request) (string, error) {
	m := urlArg.FindStringSubmatch(r.URL.String())
	if m == nil || len(m) < 1 {
		return "", fmt.Errorf("Invalid regex.", r.URL.String())
	}
	if _, err := url.Parse(m[1]); err != nil {
		return "", fmt.Errorf("Invalid url", m[1])
	}
	return m[1], nil
}

// Serves the image from the URL in the request.
// This allows us to get around CORS issues.
func remoteHandler(w http.ResponseWriter, r *http.Request) {
	img, err := getImg(r)
	if err != nil {
		log.Println(err)
		w.Write([]byte(err.Error()))
		return
	}
	defer img.Close()
	io.Copy(w, img)
}

// Serves the image generated by approximate() on the URL in the request.
func approxHandler(w http.ResponseWriter, r *http.Request) {
	sessionID, err := getSessionID(r)
	broadcastChannel := make(chan *Event)
	if err == nil {
		if session, ok := sessionManager.sessions[sessionID]; ok {
			broadcastChannel = session.broadcast
		}
	}

	broadcastChannel <- &Event{Name: "log", Properties: map[string]string{
		"text": "Starting approximation",
	}}

	img, err := getImg(r)
	if err != nil {
		log.Println(err)
		w.Write([]byte(err.Error()))
		return
	}
	defer img.Close()
	// read the image into target (type image.Image)
	_target, _, err := image.Decode(img)
	if err != nil {
		w.Write([]byte("err"))
		fmt.Println(err)
		return
	}
	if dx, dy := _target.Bounds().Dx(), _target.Bounds().Dy(); dx > MAXSIZE || dy > MAXSIZE {
		msg := fmt.Sprintf("Image of size %v.%v is too large (max size is %v)", dx, dy, MAXSIZE)
		io.Copy(w, strings.NewReader(msg))
	}

	target := toRGBA(_target)

	approximation, score := approximate(
		target,
		TRIES,
		MUTATIONS,
		PIXELSAMPLING,
		broadcastChannel,
	)
	fmt.Println(float64(score) / 1000000)
	png.Encode(w, approximation)

	broadcastChannel <- &Event{Name: "log", Properties: map[string]string{
		"text": "Approximation complete",
	}}
}

// Serve a static file.
func fileHandler(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &http.Cookie{
		Name:  "Session-ID",
		Value: uuid.New().String()})
	http.ServeFile(w, r, r.URL.Path[1:])
}

func statsHandler(w http.ResponseWriter, r *http.Request) {
	msg := fmt.Sprintf("%v iterations of %v mutations each, sampling 1/%v pixels.", TRIES, MUTATIONS, PIXELSAMPLING)
	io.Copy(w, strings.NewReader(msg))
}

// Returns the image from a URL.
func getImg(r *http.Request) (io.ReadCloser, error) {
	// Get the URL of the target image
	url, err := urlParam(r)
	if err != nil {
		return nil, err
	}
	// Fetch the image
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	return resp.Body, nil
}

func main() {
	runtime.GOMAXPROCS(4)
	port := "0.0.0.0:4000"
	fmt.Println("Running on", port)

	http.HandleFunc("/", fileHandler)
	http.HandleFunc("/remote/", remoteHandler)
	http.HandleFunc("/approx/", approxHandler)
	http.HandleFunc("/stats/", statsHandler)
	http.HandleFunc("/status/", statusHandler)

	err := http.ListenAndServe(port, nil)
	if err != nil {
		log.Fatal(err)
	}
}
